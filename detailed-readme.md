# Enhanced Behavior Tree Framework

Enhanced Behavior Tree Framework ‡πÄ‡∏õ‡πá‡∏ô library Python ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Behavior Trees ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏∑‡∏î‡∏´‡∏¢‡∏∏‡πà‡∏ô‡∏™‡∏π‡∏á ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö asynchronous ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö debugging ‡πÅ‡∏•‡∏∞ visualization

## ‚ú® ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏°‡∏ö‡∏±‡∏ï‡∏¥‡∏´‡∏•‡∏±‡∏Å

### üå≥ ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
- ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö node ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô (Sequence, Selector, Parallel, Action, Condition)
- Composite nodes ‡∏´‡∏•‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏° memory policies
- Decorator nodes ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡∏û‡∏§‡∏ï‡∏¥‡∏Å‡∏£‡∏£‡∏°
- ‡∏£‡∏∞‡∏ö‡∏ö Blackboard ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ä‡∏£‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á nodes

### üîÑ ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
- ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö async/await
- Parallel execution
- ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ lifecycle ‡∏Ç‡∏≠‡∏á nodes
- ‡∏£‡∏∞‡∏ö‡∏ö event handling

### üìä ‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÅ‡∏•‡∏∞ Debug
- Real-time visualization
- ‡∏£‡∏∞‡∏ö‡∏ö logging ‡∏ó‡∏µ‡πà‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î
- ‡∏Å‡∏≤‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
- Record ‡πÅ‡∏•‡∏∞ replay ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô

### ‚öôÔ∏è ‡∏Å‡∏≤‡∏£‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤
- ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö YAML, JSON, ‡πÅ‡∏•‡∏∞ Python configuration
- ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö configuration
- ‡∏Å‡∏≤‡∏£‡∏£‡∏ß‡∏°‡πÅ‡∏•‡∏∞ override configuration

## üöÄ ‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á

```bash
pip install behavior-tree
```

## üìñ ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô

### ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Behavior Tree ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏á‡πà‡∏≤‡∏¢

```python
import asyncio
from enhanced_behavior_tree import (
    BehaviorTreeManager,
    SequenceNode,
    ActionNode,
    ConditionNode
)

# ‡∏™‡∏£‡πâ‡∏≤‡∏á action nodes
async def check_battery():
    # ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏ö‡∏ï‡πÄ‡∏ï‡∏≠‡∏£‡∏µ‡πà
    return True

async def move_to_target():
    # ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà
    await asyncio.sleep(1)
    return True

# ‡∏™‡∏£‡πâ‡∏≤‡∏á tree
async def main():
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á manager
    manager = BehaviorTreeManager()
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á nodes
    sequence = SequenceNode("main_sequence")
    battery_check = ConditionNode(
        "check_battery",
        condition_func=check_battery
    )
    move = ActionNode(
        "move_to_target",
        action_func=move_to_target
    )
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á tree
    sequence.add_child(battery_check)
    sequence.add_child(move)
    
    # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ root node
    manager.root = sequence
    
    # ‡∏£‡∏±‡∏ô tree
    await manager.run()

if __name__ == "__main__":
    asyncio.run(main())
```

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Blackboard

```python
from enhanced_behavior_tree import Blackboard

# ‡∏™‡∏£‡πâ‡∏≤‡∏á blackboard
blackboard = Blackboard()

# ‡∏™‡∏£‡πâ‡∏≤‡∏á namespace
blackboard.create_namespace("robot_state")

# ‡πÄ‡∏ã‡πá‡∏ï‡∏Ñ‡πà‡∏≤
blackboard.set("battery_level", 85, "robot_state")
blackboard.set("position", (10, 20), "robot_state")

# ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤
battery = blackboard.get("battery_level", "robot_state")
position = blackboard.get("position", "robot_state")

# ‡∏™‡∏°‡∏±‡∏Ñ‡∏£‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô
def on_battery_changed(key, value, old_value):
    print(f"Battery changed from {old_value} to {value}")

blackboard.subscribe("battery_level", on_battery_changed, "robot_state")
```

### ‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Custom Nodes

```python
from enhanced_behavior_tree import ActionNode, NodeStatus

class CustomActionNode(ActionNode):
    """Node ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏≠‡∏á"""
    
    async def _tick(self) -> NodeStatus:
        try:
            # ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ç‡∏≠‡∏á node
            result = await self.do_something()
            
            # ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
            self.stats['total_runs'] += 1
            
            return NodeStatus.SUCCESS if result else NodeStatus.FAILURE
            
        except Exception as e:
            self.logger.error(f"Error: {e}")
            return NodeStatus.ERROR
    
    async def do_something(self):
        # ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á
        return True
```

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Configuration

```yaml
# tree_config.yaml
name: "robot_behavior"
type: "SequenceNode"
children:
  - name: "check_battery"
    type: "ConditionNode"
    properties:
      blackboard_key: "battery_level"
      namespace: "robot_state"
      operator: ">="
      expected_value: 20
  
  - name: "move_to_target"
    type: "ActionNode"
    properties:
      timeout: 5.0
      retry_count: 3
```

```python
from enhanced_behavior_tree import ConfigLoader

# ‡πÇ‡∏´‡∏•‡∏î configuration
loader = ConfigLoader()
config = loader.load_file("tree_config.yaml")

# ‡∏™‡∏£‡πâ‡∏≤‡∏á tree ‡∏à‡∏≤‡∏Å configuration
manager = BehaviorTreeManager()
manager.load_from_file("tree_config.yaml")
```

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Visualization

```python
from enhanced_behavior_tree import TreeVisualizer

# ‡∏™‡∏£‡πâ‡∏≤‡∏á visualizer
visualizer = TreeVisualizer()

# ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏ú‡∏ô‡∏†‡∏≤‡∏û
visualizer.create_graphviz(manager.root, "tree.png")

# ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡πÅ‡∏ö‡∏ö ASCII
print(visualizer.create_ascii(manager.root))

# ‡πÄ‡∏£‡∏¥‡πà‡∏° real-time monitoring
await visualizer.start_monitoring(manager)
```

## üîç ‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÅ‡∏•‡∏∞ Debug

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Logging

```python
import logging

# ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# ‡πÄ‡∏û‡∏¥‡πà‡∏° debug node
debug_node = DebugLogNode(
    "debug",
    message="Processing target",
    level="DEBUG"
)
```

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Metrics

```python
# ‡∏î‡∏π‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
stats = manager.get_stats()
print(f"Total ticks: {stats['total_ticks']}")
print(f"Success rate: {stats['success_count'] / stats['total_ticks']:.2%}")

# ‡∏î‡∏π‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Ç‡∏≠‡∏á node
action_node = manager.root.children[0]
print(f"Action runs: {action_node.stats['total_runs']}")
print(f"Average duration: {action_node.stats['average_duration']:.3f}s")
```

## üõ† Advanced Features

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Parallel Execution

```python
from enhanced_behavior_tree import ParallelNode, ParallelPolicy

# ‡∏™‡∏£‡πâ‡∏≤‡∏á parallel node
parallel = ParallelNode(
    "parallel_tasks",
    policy=ParallelPolicy.REQUIRE_ONE,
    success_threshold=2
)

# ‡πÄ‡∏û‡∏¥‡πà‡∏° tasks
parallel.add_child(task1)
parallel.add_child(task2)
parallel.add_child(task3)
```

### ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô Decorators

```python
from enhanced_behavior_tree.nodes.decorators import (
    RetryNode,
    TimeoutNode,
    InverterNode
)

# Retry decorator
retry = RetryNode(
    "retry_move",
    max_attempts=3,
    delay=1.0
)
retry.add_child(move_node)

# Timeout decorator
timeout = TimeoutNode(
    "timeout_action",
    timeout=5.0
)
timeout.add_child(action_node)
```

## ü§ù ‡∏Å‡∏≤‡∏£ Contribute

1. Fork repository
2. ‡∏™‡∏£‡πâ‡∏≤‡∏á feature branch
3. Commit ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á
4. Push ‡πÑ‡∏õ‡∏¢‡∏±‡∏á branch
5. ‡∏™‡∏£‡πâ‡∏≤‡∏á Pull Request

## üìÑ License

‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡∏†‡∏≤‡∏¢‡πÉ‡∏ï‡πâ MIT License - ‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÉ‡∏ô [LICENSE](LICENSE)

## üìö Documentation

‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏≠‡∏Å‡∏™‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°:
- [API Reference](docs/api_reference.md)
- [Architecture Overview](docs/architecture.md)
- [Examples](docs/examples.md)
